---
title: "Targeted Lipdomics - Data Explorer"
output: html_notebook
---

Targeted Lipidomcis data pre-processing and data explorer

Includes:

 -> Internal standard check to test for sample preparation errors
 -> Total ion count check to test for mis-injections
 ->

```{r, read in data,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
package_list <- c("plyr", "tidyverse", "janitor", "gridExtra", "ggpubr", "readxl", "cowplot", "scales", "devtools", "metabom8", "shiny", "plotly", "svDialogs", "DataEditR", "htmlwidgets", "httr")
loaded_packages <- lapply(package_list, require, character.only = TRUE)
rm(loaded_packages)
lipidomics_functions_script <- GET(url = "https://raw.githubusercontent.com/lukewhiley/metabolomics_code/main/functions/LGW_function_lipidomics_tools.r") %>% content(as = "text")
eval(parse(text = lipidomics_functions_script), envir = .GlobalEnv)
rm(lipidomics_functions_script)

#user input here for project name and user initials
if(exists("project_name") != TRUE){project_name <- dlgInput("what is the name of the project? This must match the string in Filename", "example_project")$res}
if(exists("user_name") != TRUE){user_name <- dlgInput("Insert your initials", "example_initials")$res}

# read in master data
temp_answer <- dlgInput("Do you want to read in new data?", "yes/no")$res
if(temp_answer == "yes"){dlg_message("Open metabolite data csv by selecting the CSV generated by the Skyline data processing", type = 'ok')
master_lipid_data <- read_csv(file = file.choose(.)) %>% clean_names %>% rename(lipid_target = peptide, lipid_class = protein)
}

sampleID <- master_lipid_data$replicate %>% unique() # create list of sample IDs
lipid <- master_lipid_data$lipid_target %>% unique() # create list of lipid targets
lipid_class_list <- master_lipid_data %>% select(lipid_class) %>% unique()

individual_lipid_data <- apply(as_tibble(lipid), 1, function(lip){
  #browser()
  sampleID <- master_lipid_data$replicate %>% unique() %>% as_tibble() # create list of sample IDs
  temp_data <- master_lipid_data %>% filter(lipid_target == lip) %>% select(replicate, area)
  colnames(temp_data) <- c("value", lip) 
  temp_data <- left_join(sampleID, temp_data, by = "value") 
  #temp_data <- temp_data %>% select(lip)
  }) %>% bind_cols() %>% select(all_of(lipid)) %>% add_column(sampleID, .before = 1)

plate_id <- str_extract(individual_lipid_data$sampleID, "PLIP.*")
plate_id <- substr(plate_id, 0,15)
plate_id <- paste(plate_id, sub(".*\\_", "", individual_lipid_data$sampleID), sep="_")

individual_lipid_data <- individual_lipid_data %>% add_column(plate_id, .before = 2) %>% arrange(plate_id)
class_lipid_data <- create_lipid_class_data_summed(individual_lipid_data)

```

Summed SIL internal standard check to look for preparation errors. Samples are removed if the TIC is either > or < 2sd above or below the mean summed SIL internal standard TIC of the dataset. Sample SIL TIC > 2 SD indicates high concentration of SIL, so likely as a result of excess SIL IS added. < 2SD below mean indicates too little volume added of SIL internal standard added. 

```{r, step 1 - SIL internal standard check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
total_summed_sil <- apply(individual_lipid_data %>% select(sampleID), 1, function(summedSIL){
  temp_data <- individual_lipid_data %>% filter(sampleID == summedSIL) %>% select(-sampleID) %>% select(contains("SIL")) %>% rowSums(na.rm = TRUE)
}) %>% c() %>% as_tibble() %>%  add_column(individual_lipid_data$sampleID, .before = 1) %>% 
  rename(SIL_TIC = value, sampleID = "individual_lipid_data$sampleID")

plateid <- str_extract(individual_lipid_data$sampleID, "PLIP.*")
plateid <- substr(plateid, 0,15)
plate_id <- paste(plateid, sub(".*\\_", "", individual_lipid_data$sampleID), sep="_")

total_summed_sil <- total_summed_sil %>% add_column(plate_id, .before = 2) %>% arrange(plate_id)
total_summed_sil$sample_idx <- c(1:nrow(total_summed_sil))
total_summed_sil$LOG_SIL_TIC <- log(total_summed_sil$SIL_TIC)

#flag samples with SIL x standard deviations below mean
temp_answer <- dlgInput("What do you wish to set for the fail cut off filter.  x number of standard deviations from the mean", "e.g.   x = 2")$res

mean_sil_tic <- mean(total_summed_sil$SIL_TIC)
sd_sil_tic <- sd(total_summed_sil$SIL_TIC)
sil_sd_mean_cut_off_lower <- mean_sil_tic - (as.numeric(temp_answer)*sd_sil_tic)
sil_sd_mean_cut_off_upper <- mean_sil_tic + (as.numeric(temp_answer)*sd_sil_tic)

sil_qc_fail <- total_summed_sil$sampleID[which(total_summed_sil$SIL_TIC < sil_sd_mean_cut_off_lower | total_summed_sil$SIL_TIC > sil_sd_mean_cut_off_upper)] %>% as_tibble %>% rename(sampleID = value)
sil_qc_fail$fail_point <- "sil"

#sil_qc_fail
temp_answer <- dlgInput(paste(nrow(sil_qc_fail), "sample FAILED the SIL QC check.  Do you want to remove failed samples?"), "yes/no")$res
if(temp_answer == "yes"){individual_lipid_data_sil_filtered <- individual_lipid_data %>% filter(!sampleID %in% sil_qc_fail$sampleID)}

#visualise for reports
total_summed_sil$removed <- "pass_qc"
total_summed_sil$removed[total_summed_sil$sampleID %in% sil_qc_fail$sampleID] <- "removed"

p <- plot_ly(type = "scatter", total_summed_sil, x = ~sample_idx, y = ~LOG_SIL_TIC, text = ~sampleID, color = ~removed, colors = c("lightblue3", "red"))

plate_number <- unique(plate_id) %>% substr(14,14) %>% unique()
plate_idx <- lapply(unique(plateid), function(plateID){grep(plateID, total_summed_sil$sampleID)[1]}) %>% unlist()
for (idx_line in 2:length(plate_idx)){
    p <- add_trace(p, x = plate_idx[idx_line], type = 'scatter', mode = 'lines', color = paste("plate_", plate_number[idx_line], sep=""), line = list(color = "grey", dash = "dash"), showlegend = FALSE)
}
p <- add_trace(p, y = log(sil_sd_mean_cut_off_lower), type = 'scatter', mode = 'lines', color = "SIL QC threshold", line = list(color = "red", dash = "dash"))
p <- add_trace(p, y = log(sil_sd_mean_cut_off_upper), type = 'scatter', mode = 'lines', color = "SIL QC threshold", line = list(color = "red", dash = "dash"));p
```

Total ion count check to look for mis-injections. Samples are removed if the TIC is < 2sd below the mean TIC of the dataset.

```{r, Total ion count check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}

total_summed_tic <- apply(individual_lipid_data_sil_filtered %>% select(sampleID), 1, function(summedTIC){
  #browser()
  temp_data <- individual_lipid_data_sil_filtered %>% filter(sampleID == summedTIC) %>% select(-sampleID, -plate_id) %>% select(!contains("SIL")) %>% rowSums(na.rm = TRUE)
}) %>% c() %>% as_tibble() %>%  add_column(individual_lipid_data_sil_filtered$sampleID, .before = 1) %>% 
  rename(summed_TIC = value, sampleID = "individual_lipid_data_sil_filtered$sampleID")

plateid <- str_extract(individual_lipid_data_sil_filtered$sampleID, "PLIP.*")
plateid <- substr(plateid, 0,15)
plate_id <- paste(plateid, sub(".*\\_", "", individual_lipid_data_sil_filtered$sampleID), sep="_")

total_summed_tic <- total_summed_tic %>% add_column(plate_id, .before = 2) %>% arrange(plate_id)
total_summed_tic$sample_idx <- c(1:nrow(total_summed_tic))
total_summed_tic$LOG_summed_TIC <- log(total_summed_tic$summed_TIC)

#flag samples with SIL x number of standard deviations below mean

temp_answer <- dlgInput("What do you wish to set for the fail cut off filter.  x number of standard deviations from the mean", "e.g.   x = 2")$res
while(is.na(as.numeric(temp_answer))){
  temp_answer <- dlgInput("You did not enter a numeric value.  What do you wish to set for the fail cut off filter.  x number of standard deviations from the mean", "e.g.   x = 2")$res
}

mean_summed_tic <- mean(total_summed_tic$summed_TIC)
sd_summed_tic <- sd(total_summed_tic$summed_TIC)
tic_sd_mean_cut_off <- mean_summed_tic - (as.numeric(temp_answer)*sd_summed_tic)

tic_qc_fail <- total_summed_tic$sampleID[which(total_summed_tic$summed_TIC < tic_sd_mean_cut_off)] %>% as_tibble %>% rename(sampleID = value)
tic_qc_fail$fail_point <- "tic"

temp_answer <- dlgInput(paste(nrow(tic_qc_fail), "sample FAILED the SIL QC check.  Do you want to remove failed samples?"), "yes/no")$res
#while(!is.numeric(which(c("yes", "no") == temp_answer))){
 # temp_answer <- dlgInput("You did not enter a yes or no value.  Do you want to remove failed samples?"), "yes/no")$res
#}

if(temp_answer == "yes"){individual_lipid_data_sil_tic_filtered <- individual_lipid_data_sil_filtered %>% filter(!sampleID %in% tic_qc_fail$sampleID)}

#visualise for reports
total_summed_tic$removed <- "pass_qc"
total_summed_tic$removed[total_summed_tic$sampleID %in% tic_qc_fail$sampleID] <- "removed"

p <- plot_ly(type = "scatter", mode = "markers", total_summed_tic, x = ~sample_idx, y = ~LOG_summed_TIC, text = ~sampleID, color = ~removed, colors = c("lightblue3", "red"))


plate_number <- unique(plate_id) %>% substr(14,14) %>% unique()
plate_idx <- lapply(unique(plateid), function(plateID){grep(plateID, total_summed_tic$sampleID)[1]}) %>% unlist()
for (idx_line in 2:length(plate_idx)){
    p <- add_trace(p, x = plate_idx[idx_line], type = 'scatter', mode = 'lines', color = paste("plate_", plate_number[idx_line], sep=""), line = list(color = "grey", dash = "dash"), showlegend = FALSE)
}
p <- add_trace(p, y = log(tic_sd_mean_cut_off), type = 'scatter', mode = 'lines', color = "SIL QC threshold", line = list(color = "red", dash = "dash"));p

```


The next step evaluates SIL internal standards in the LTR samples only. Check 1 plots summed SIL IS to see if any abnormal LTE samples remain.


```{r, evaluate filtered data - LTR SIL area check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
qc_data <- individual_lipid_data_sil_tic_filtered %>% filter(!grepl("conditioning", sampleID)) %>% filter(grepl("LTR", sampleID))

area_sum <- apply(qc_data, 1, function(peakArea){
  #browser()
    func_data <- peakArea %>% as_tibble(rownames = "lipid") %>% filter(!grepl("sampleID", lipid)) %>% filter(grepl("SIL", lipid)) %>% select(value) %>% sapply(as.numeric) %>% colSums(na.rm = TRUE)
    }) %>% as_tibble() %>% add_column(qc_data$sampleID, qc_data$plate_id, .before = 1) %>% 
  rename("sampleID" = "qc_data$sampleID", "plate_id" = "qc_data$plate_id", "summed_area" = "value")

area_mean <- mean(area_sum$summed_area)
(sd(area_sum$summed_area)*100)/area_mean
upper_cutoff <- area_mean + 2*sd(area_sum$summed_area)
lower_cutoff <- area_mean - 2*sd(area_sum$summed_area)

area_sum$normalisation_factor <- area_mean/area_sum$summed_area
area_sum$sample_idx <- c(1:nrow(area_sum))
#area_sum$summed_area <- area_sum$summed_area * area_sum$normalisation_factor
area_sum$LOG_summed_TIC <- log(area_sum$summed_area)

#visualise
plot_limits <- c(area_mean/2, area_mean*2) %>% log()

p <- plot_ly(type = "scatter", mode = "markers", area_sum, x = ~sample_idx, y = ~LOG_summed_TIC, text = ~sampleID, colors = c("lightblue3")) %>%
    layout(yaxis = list(range = c(plot_limits)))

#add vertical lines to represent plate boundaries - only runs if multiple plates exist using ANPC LIMS fine name style
plateid <- str_extract(area_sum$sampleID, "PLIP.*")
if(100/length(plateid)*length(which(is.na(plateid))) < 50){
plateid <- substr(plateid, 0,15)
plate_id <- paste(plateid, sub(".*\\_", "", area_sum$sampleID), sep="_")
plate_number <- unique(plate_id) %>% substr(14,14) %>% unique()
plate_idx <- lapply(unique(plateid), function(plateID){grep(plateID, area_sum$sampleID)[1]}) %>% unlist()

for (idx_line in 2:length(plate_idx)){
  p <- p %>% add_segments(x = plate_idx[idx_line], xend = plate_idx[idx_line], y = plot_limits[1], yend = plot_limits[2], line = list(color = "grey", dash = "dash"), showlegend = FALSE)
}
}

p <- p %>% add_segments(y = log(area_mean), yend = log(area_mean), x = 0, xend = nrow(area_sum), line = list(color = "black", dash = "dash"), showlegend = FALSE)
p <- p %>% add_segments(y = log(upper_cutoff), yend = log(upper_cutoff), x = 0, xend = nrow(area_sum), line = list(color = "red", dash = "dot"), showlegend = FALSE)
p <- p %>% add_segments(y = log(lower_cutoff), yend = log(lower_cutoff), x = 0, xend = nrow(area_sum), line = list(color = "red", dash = "dot"), showlegend = FALSE)


p_sil <- p
p_sil

sil_area_sum <- area_sum

```

The next step evaluates summed metabolites that are not-internal standards in the LTR samples only. The result is a plot that presents summed lipid metabolites, again, to see if any abnormal LTE samples remain.

```{r, evaluate filtered data - LTR non-SIL area check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}

area_sum <- apply(qc_data, 1, function(peakArea){
  #browser()
    func_data <- peakArea %>% as_tibble(rownames = "lipid") %>% filter(!grepl("sampleID", lipid)) %>% filter(!grepl("SIL", lipid)) %>% select(value) %>% sapply(as.numeric) %>% colSums(na.rm = TRUE)
    }) %>% as_tibble() %>% add_column(qc_data$sampleID, qc_data$plate_id, .before = 1) %>% 
  rename("sampleID" = "qc_data$sampleID", "plate_id" = "qc_data$plate_id", "summed_area" = "value")

area_sum$sample_idx <- c(1:nrow(area_sum))
area_sum$LOG_summed_TIC <- log(area_sum$summed_area)

area_mean <- mean(area_sum$summed_area)
(sd(area_sum$summed_area)*100)/area_mean
upper_cutoff <- area_mean + (2*sd(area_sum$summed_area))
lower_cutoff <- area_mean - (2*sd(area_sum$summed_area))

#visualise
plot_limits <- c(area_mean/5, area_mean*5) %>% log()
p <- plot_ly(type = "scatter", area_sum, x = ~sample_idx, y = ~LOG_summed_TIC, text = ~sampleID, colors = c("lightblue3")) %>%
    layout(yaxis = list(range = c(plot_limits)))

#add vertical lines to represent plate boundaries - only runs if multiple plates exist using ANPC LIMS fine name style
plateid <- str_extract(area_sum$sampleID, "PLIP.*")
if(100/length(plateid)*length(which(is.na(plateid))) < 50){
plateid <- substr(plateid, 0,15)
plate_id <- paste(plateid, sub(".*\\_", "", area_sum$sampleID), sep="_")
plate_number <- unique(plate_id) %>% substr(14,14) %>% unique()
plate_idx <- lapply(unique(plateid), function(plateID){grep(plateID, area_sum$sampleID)[1]}) %>% unlist()

for (idx_line in 2:length(plate_idx)){
  p <- p %>% add_segments(x = plate_idx[idx_line], xend = plate_idx[idx_line], y = plot_limits[1], yend = plot_limits[2], line = list(color = "grey", dash = "dash"), showlegend = FALSE)
}
}

p <- p %>% add_segments(y = log(area_mean), yend = log(area_mean), x = 0, xend = nrow(area_sum), line = list(color = "black", dash = "dash"), showlegend = FALSE)
p <- p %>% add_segments(y = log(upper_cutoff), yend = log(upper_cutoff), x = 0, xend = nrow(area_sum), line = list(color = "red", dash = "dot"), showlegend = FALSE)
p <- p %>% add_segments(y = log(lower_cutoff), yend = log(lower_cutoff), x = 0, xend = nrow(area_sum), line = list(color = "red", dash = "dot"), showlegend = FALSE)

p

non_sil_area_sum <- area_sum


```

The next step normalises the data using the internal standard for each lipid target, and plots the result. LTR samples where the summed  ratio falls outside of 2 standard deviations from the mean were removed as a failed LTR at this stage.

```{r, evaluate filtered data - LTR non-SIL/SIL ratio summed area check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}

area_sum <- non_sil_area_sum

area_sum$summed_area <- non_sil_area_sum$summed_area/((non_sil_area_sum$summed_area+sil_area_sum$summed_area)*2)

##############HERE
area_sum$LOG_summed_TIC <- log(area_sum$summed_area+1)

area_mean <- mean(area_sum$summed_area)
(sd(area_sum$summed_area)*100)/area_mean
upper_cutoff <- (area_mean + (1.5*sd(area_sum$summed_area)))+1
lower_cutoff <- (area_mean - (1.5*sd(area_sum$summed_area)))+1

#visualise
plateid <- str_extract(area_sum$sampleID, "PLIP.*")
plateid <- substr(plateid, 0,15)
plate_id <- paste(plateid, sub(".*\\_", "", area_sum$sampleID), sep="_")
plate_number <- unique(plate_id) %>% substr(14,14) %>% unique()
plate_idx <- lapply(unique(plateid), function(plateID){grep(plateID, area_sum$sampleID)[1]}) %>% unlist()

plot_limits <- c((area_mean/2)+1, (area_mean*2)+1) %>% log()

p <- plot_ly(type = "scatter", area_sum, x = ~sample_idx, y = ~LOG_summed_TIC, text = ~sampleID, colors = c("lightblue3")) %>%
    layout(yaxis = list(range = c(plot_limits)))

for (idx_line in 2:length(plate_idx)){
  p <- p %>% add_segments(x = plate_idx[idx_line], xend = plate_idx[idx_line], y = plot_limits[1], yend = plot_limits[2], line = list(color = "grey", dash = "dash"), showlegend = FALSE, text = plateid[plate_idx[idx_line]])
}

p <- p %>% add_segments(y = log(area_mean), yend = log(area_mean), x = 0, xend = nrow(area_sum), line = list(color = "black", dash = "dash"), showlegend = FALSE, text = "mean")
p <- p %>% add_segments(y = log(upper_cutoff), yend = log(upper_cutoff), x = 0, xend = nrow(area_sum), line = list(color = "red", dash = "dot"), showlegend = FALSE, text = "mean + 2 sd")
p <- p %>% add_segments(y = log(lower_cutoff), yend = log(lower_cutoff), x = 0, xend = nrow(area_sum), line = list(color = "red", dash = "dot"), showlegend = FALSE, text = "mean - 2 sd")


ratio_qc_fail_lower <- area_sum$sampleID[which(area_sum$LOG_summed_TIC < log(lower_cutoff))] %>% as_tibble() %>% rename(sampleID = value)
ratio_qc_fail_upper <- area_sum$sampleID[which(area_sum$LOG_summed_TIC > log(upper_cutoff))] %>% as_tibble() %>% rename(sampleID = value)
ratio_qc_fail <- bind_rows(ratio_qc_fail_lower, ratio_qc_fail_upper)
ratio_qc_fail

p
```

Plots shows the final data set and TIC ratio (summed metabolite lipid taret/summed SIL internal standard)


```{r, evaluate filtered data - LTR non-SIL/SIL ratio individual lipid area check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}

#import transition report 3
filtered_data <- individual_lipid_data_sil_tic_filtered %>% filter(!sampleID %in% ratio_qc_fail$sampleID) %>% 
  filter(!grepl("conditioning", sampleID))

sil_target_list <- read_csv(file = file.choose(.)) %>% clean_names
lipid_data <- filtered_data %>% select(-sampleID, - plate_id) %>% select(!contains("SIL"))
sil_data <- filtered_data %>% select(-sampleID, - plate_id) %>% select(contains("SIL"))

normalisation_factor <- lapply(filtered_data$sampleID, function(sampleNORM){
  #browser()
  func_data <- filtered_data %>% filter(sampleID == sampleNORM) %>% select(contains("SIL")) %>% rowSums(na.rm = TRUE)
}) %>% unlist

ratio_data <- apply(as_tibble(colnames(lipid_data)), 1, function(LIPID){
  #browser()
  func_data <- lipid_data %>% select(LIPID)
  sil_to_use <- sil_target_list$note[which(sil_target_list$precursor_name==LIPID)]
  func_data_sil <- sil_data %>% select(sil_to_use)
  normalised_data <- (func_data/((func_data+func_data_sil)*2))
  #normalised_data <- (func_data/((func_data+func_data_sil)))/normalisation_factor
  #normalised_data <- (func_data/func_data_sil)+normalisation_factor
  #normalised_data <- func_data/(func_data+normalisation_factor)
  #normalised_data <- func_data/func_data_sil
  normalised_data
}) %>% bind_cols() %>% add_column(filtered_data$sampleID, filtered_data$plate_id, .before = 1)

colnames(ratio_data) <- c("sampleID", "plateID", colnames(lipid_data))

ltr_rsd <- apply(as_tibble(colnames(lipid_data)), 1, function(RSD){
  #browser()
  func_data <- ratio_data %>% filter(grepl("LTR", sampleID)) %>% select(RSD) 
  (sd(func_data$value)*100)/mean(func_data$value)
  }) %>% as_tibble() %>% add_column(colnames(lipid_data), .before = 1)

colnames(ltr_rsd) <- c("lipid", "RSD")
paste("number of feature ratios with with an LTR RSD of <30% =", length(which(ltr_rsd$RSD < 30)))
paste("number of feature ratios with with an LTR RSD of <20% =", length(which(ltr_rsd$RSD < 20)))
paste("number of feature ratios with with an LTR RSD of <15% =", length(which(ltr_rsd$RSD < 15)))
paste("number of feature ratios with with an LTR RSD of <10% =", length(which(ltr_rsd$RSD < 10)))

ltr_rsd <- ltr_rsd %>% arrange(RSD)
plot(ltr_rsd$RSD)

lipid_keep_list <- ltr_rsd %>% filter(RSD < 30)

final_dataset <- ratio_data %>% select(sampleID, plateID, all_of(lipid_keep_list$lipid))
  

total_summed_ratio <- apply(final_dataset %>% select(sampleID), 1, function(summedTIC){
  #browser()
  temp_data <- final_dataset %>% filter(sampleID == summedTIC) %>% select(-sampleID, -plateID) %>% rowSums(na.rm = TRUE)
}) %>% c() %>% as_tibble() %>%  add_column(final_dataset$sampleID, .before = 1) %>% 
  rename(summed_TIC = value, sampleID = "final_dataset$sampleID")
total_summed_ratio$sample_idx <- c(1:nrow(total_summed_ratio))

sd(total_summed_ratio$summed_TIC*100)/mean(total_summed_ratio$summed_TIC)

total_summed_ratio$sample <- "sample"
total_summed_ratio$sample[grep("LTR", total_summed_ratio$sampleID)] <- "LTR"

p <- plot_ly(type = "scatter", total_summed_ratio, x = ~sample_idx, y = ~summed_TIC, text = ~sampleID, color = ~sample, colors = c("red", "lightblue"));p

p

```

Plot to check each lipid class for any trends in the final dataset

```{r, evaluate final filtered data - lipid class check,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}

final_individual_lipid_data <- final_dataset

final_class_lipid_data <- create_lipid_class_data_summed(final_dataset)

lipid_class_list <- final_individual_lipid_data %>% select(contains("(")) %>% colnames() 
lipid_class_list <- sub("\\(.*", "", lipid_class_list) %>% unique()
lipid_class_list <- lipid_class_list[!grepl("sampleID", lipid_class_list)] %>% as_tibble()

#add ltr TRUE/FALSE column

final_class_lipid_data$is_ltr <- "sample"
final_class_lipid_data$is_ltr[grep("LTR", final_class_lipid_data$sampleID)] <- "LTR"

plotlist <- apply(lipid_class_list %>% select(value), 1, function(lipidClass){
  browser()
  #plot_data <- final_class_lipid_data %>% select("sampleID", "is_ltr", all_of(lipidClass))
  plot_data <- final_class_lipid_data %>% select("sampleID", "is_ltr", all_of(lipidClass)) %>% 
    rename(ms_response = value) 
  plate_id <- str_extract(plot_data$sampleID, "PLIP.*")
  plate_id <- substr(plate_id, 0,15)

  plot_data$sample_index <- paste(plate_id, sub(".*\\_", "", plot_data$sampleID), sep="_")
  plot_data <- plot_data %>% arrange(sample_index)
  plot_data$idx <- 1:nrow(plot_data)

  plot_data_ltr <- plot_data %>% filter(is_ltr == "LTR")
  #plot_data <- plot_data %>% filter(is_ltr == "sample")
  
  plate_idx <- lapply(unique(plate_id), function(plateID){
  grep(plateID, plot_data$sampleID)[1]
  }) %>% unlist
  
  p <- plot_ly(type = 'scatter',  mode   = 'markers', plot_data, x = ~idx, y = ~ms_response, text = ~sampleID, color = ~is_ltr,  colors = c("red", "lightblue3"), showlegend = FALSE) %>% 
    layout(xaxis = list(title = paste(lipidClass)))
  
  p <- add_trace(p, data = plot_data_ltr, x = ~idx, y = ~ms_response, text = ~sampleID, color = ~is_ltr,  colors = c("red", "lightblue3"), showlegend = FALSE)
   
plate_number <- unique(plate_id) %>% substr(14,14)

plot_limits <- c(min(plot_data$ms_response), max(plot_data$ms_response))
       
for (idx_line in 2:length(plate_idx)){
  p <- p %>% add_segments(x = plate_idx[idx_line], xend = plate_idx[idx_line], y = plot_limits[1], yend = plot_limits[2], line = list(color = "grey", dash = "dash"), showlegend = FALSE, text = plateid[plate_idx[idx_line]])
}
  p
})

ltr_check_final_plot <- subplot(plotlist, nrows = 4, titleX = TRUE, margin = c(0.01,0.01,0.05,0.05))

saveWidget(ltr_check_final_plot, file = "ltr_check_final_plot.html")
browseURL("ltr_check_final_plot.html")

ltr_check_final_plot
```


PCA plot including LTR to see how LTR cluster in relation to complete dataset. Plots are produced for individual lipids and for summed lipid class

```{r, evaluate final filtered data - PCA of data to check LTR cluster,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
individual_lipid_data$sample_class <- "sample"
individual_lipid_data$sample_class[grep("LTR", individual_lipid_data$sampleID)] <- "LTR"

class_lipid_data$sample_class <- "sample"
class_lipid_data$sample_class[grep("LTR", class_lipid_data$sampleID)] <- "LTR"

plot_colours <- c("red", "lightblue3")
label_sampleIDs <- FALSE

lipids_pca(individual_lipid_data, class_lipid_data, multivariate_class = "sample_class", plot_label = "sampleID")



```

PCA plot for individual lipids within each lipid class. To see if any lipid class contains a trend in the data.

```{r, PCA sub plots,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
lipid_class_list <- class_lipid_data %>% select(-sampleID) %>% colnames() %>% as_tibble()

for (idx_lipid in 1:nrow(lipid_class_list)){
  loop_data <- individual_lipid_data
  colnames(loop_data) <- paste("_",colnames(loop_data), sep = "")
  loop_data <- loop_data %>% select("_sampleID", contains(paste("_", lipid_class_list$value[idx_lipid],"(", sep = "")))
  colnames(loop_data) <- sub("_", "", colnames(loop_data))
  loop_data$sample_class <- "sample"
  loop_data$sample_class[grep("LTR", loop_data$sampleID)] <- "LTR"
  
plot_colours <- c("red", "lightblue3")
label_sampleIDs <- FALSE

if(ncol(select(loop_data, contains("("))) >2){
lipids_pca(loop_data, NA, multivariate_class = "sample_class", plot_label = "sampleID")
}
}



```
Final PCA check to see if any biological trend appears in the dataset, in addition to LTR run order trends.

```{r, biological PCA,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
individual_lipid_data <- final_dataset
class_lipid_data <- create_lipid_class_data_summed(final_dataset)

lipid_class_list <- class_lipid_data %>% select(-sampleID) %>% colnames() %>% as_tibble()


metadata <- read_delim(file = file.choose(.), delim = "\t") %>% clean_names() #20200921_metadata_with_severity_grouping.txt
cov_codes <- read_delim(file = file.choose(.), delim = "\t") %>% clean_names() #sampleDescriptionList_matched_codes.txt
cov_codes$match_code <- paste(cov_codes$patient_id, cov_codes$tmp_day, sep="_D")
metadata <- metadata %>% rename(match_code = sample_id)

matched_metadata <- full_join(metadata, cov_codes, by = "match_code")

#
pca_metadata <- matched_metadata %>% select(sample_id, covid_group) %>% rename(covid_id = sample_id)

individual_lipid_data$covid_id <- str_extract(individual_lipid_data$sampleID, "COV.*")
individual_lipid_data$covid_id <- substr(individual_lipid_data$covid_id, 0,8)
individual_lipid_data$covid_group <- NA
for(idx_meta in 1:nrow(individual_lipid_data)){
    meta_check <- pca_metadata$covid_group[which(pca_metadata$covid_id == individual_lipid_data$covid_id[idx_meta])]
  if(length(meta_check) > 0){
  individual_lipid_data$covid_group[idx_meta] <- pca_metadata$covid_group[which(pca_metadata$covid_id == individual_lipid_data$covid_id[idx_meta])]
}
}
individual_lipid_data$covid_group[grepl("LTR", individual_lipid_data$sampleID)] <- "LTR"

class_lipid_data$covid_id <- str_extract(class_lipid_data$sampleID, "COV.*")
class_lipid_data$covid_id <- substr(class_lipid_data$covid_id, 0,8)
class_lipid_data$covid_group <- NA
for(idx_meta in 1:nrow(class_lipid_data)){
    meta_check <- pca_metadata$covid_group[which(pca_metadata$covid_id == class_lipid_data$covid_id[idx_meta])]
  if(length(meta_check) > 0){
  class_lipid_data$covid_group[idx_meta] <- pca_metadata$covid_group[which(pca_metadata$covid_id == class_lipid_data$covid_id[idx_meta])]
}
}
class_lipid_data$covid_group[grepl("LTR", class_lipid_data$sampleID)] <- "LTR"

plot_colours <- c("lightblue3", "grey", "grey", "lightblue3", "darkgreen", "darkorange")
label_sampleIDs <- FALSE

pca_plots <- lipids_pca(individual_lipid_data_2, class_lipid_data_2, multivariate_class = "covid_group", plot_label = "covid_group")

saveWidget(pca_plots[[1]], file = "tmp.html")
browseURL("tmp.html")

#class_lipid_data %>% select(sampleID, covid_id, covid_group)

individual_lipid_data_2 <- filter(individual_lipid_data, !grepl("LTR", sampleID))
class_lipid_data_2 <- filter(class_lipid_data, !grepl("LTR", sampleID))

#individual_lipid_data$sampleID
#matched_metadata

source('LGW_lipidomics_fuctions.R')
```

```{r,  write out final dataset,  echo = FALSE, results = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}

final_data_for_export <- individual_lipid_data %>% filter(!grepl("LTR",sampleID))

write_csv(final_data_for_export, "2021-targeted_lipidomics_cambridge_lipid_data_v1.csv")

write_csv(individual_lipid_data, "2021-targeted_lipidomics_cambridge_lipid_data_v1_WITH_LTR.csv")


```






